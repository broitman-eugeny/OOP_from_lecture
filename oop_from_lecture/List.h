#pragma once
#include <fstream>
#include <iostream>
#include "Time.h"

/*14.11.16 Д/з добавить указатель last (указатель на конец списка) и доработать написанные алгоритмы*/

class List						//Класс Список (List)
{
protected:
	
	class Elem					//Класс элемент списка (Elem)
	{
		Time * data;			//Указатель на содержимое (по умолчанию объявлен как private)

		Elem * next;			//Указатель на следующий элемент списка	(по умолчанию объявлен как private)

	public:
		//Конструкторы:
		Elem(Time *);			//Конструктор класса Elem принимающий на вход указатель на объект типа Time 
		
		Elem(const Elem &);		//Конструктор копирования. На воход принимает другой объект такого же типа (Elem)
		
		//Деструктор:
		~Elem();				//Деструктор
		
		//Геттеры:
		Elem *getNext();		//Метод при вызове которого получаем указатель на следующий элемент (то на что указывает указатель next в стр12)
		
		Time *getData();		//Метод получающий содержимое объекта в виде указателя на объект типа Time (н-р: Time * tPtr = текущий_элемент.getData())

		//Сеттер:
		void setNext(Elem *);	//Метод позволяющий устанавливать связь между текущим объектом и следующим (установить следующий)
		
		//Методы сравения:
		int compare(Elem *);	//Метод для сравнения текущего объекта с передаваемым по указателю в параметрах (н-р: текущий_элемент.compare(объект с которым сравниваем))

		int compare(Time * t);	//Возвращает в случае равенства 0, -1 - если obj1 < obj2, +1 - если obj1 > obj2
	};

	Elem *head;					//Переменная head для хранения указателя на заголовочный объект типа Elem

	Elem *last;					//Перемення для хранения указателя на конечный элемент типа Elem
	
	int count;					//Переменная для хранения значения количества содержащихся элементов

public:

	List();						//Конструктор по умолчанию

	~List();					//Деструктор

	void add(Time *);			//Добавление используя указатель на объект типа Time

	Time *remove(int);			//Удаление по индексу
	
	Time *remove(Time *);		//Удаление по содержимому (используя указатель на объект типа Time)
	
	List& concat(const List&);	//Соединение двух списков с возвращение самого списка в качестве параметра другой список
								//При этом метод ввозвращает ссылку на самого себя для того чтобы была возможность использовать
								//множественную конкатенацию. Например: Список1.concat(Список2).concat(Список3);
	
	List& copy(const List&);	//Копирование списка
	
	int search(Time *);			//Поиск по списку некого содержимого, на которое указывает указатель на объект типа Time, 
								//в качестве результата возвращает индекс искомого элемента 
	void sort();				//Сортировка
	
	void save(std::ofstream &);	//Метод для сохранения в файл (сериализация)

	void load(std::ifstream &);	//Метод для загрузки из файла (десериализация)

	Time *get(int) const;		//Метод для получения указателя на содержимое (на объект типа Time) используя индекс
	
	int getCount();				//Меотод для получения количества элементов в списке. Возвращает int

	List& operator+(Time *);	//прототип? перегрузки List + Time

	List& operator+(const List&);	//Перегрузка List + List

	List& operator-(Time*);		//Перегрузка List - Time

	List& operator-();			//Перегрузка -List

	friend std::ostream& operator<<(std::ostream &,List&);		//Перегрузка оператора помещения в поток

	friend std::istream& operator>> (std::istream &, List&);	//Перегрузка оператора извлечения из потока
};

/*
	Перегрузка операторов
	List + Time
	List + List
	List - Time
	ios<<List
	ios>>List
	-List	
	*/